
#1. Find a simple configuration file format and code to load it that
    supports key=value and key=list type settings.

Example client.conf:
private_key=/etc/bdr/client/private.key
public_key =/etc/bdr/client/public.key
backup_dirs_secure = /home /etc /var/spool/mail /
backup_dirs_less_secure = /usr /lib /var 
  #less_secure allows for global dedupe but is less secure.
server = my-master-p2p.domain.com
local_sqlite = /etc/bdr/fs-meta.sql
purge_deleted_files = 30 #days
queue_blobs= /var/lib/bdr
notify_email = joe@foo.com

Example server.conf:
private_key=/etc/bdr/server/private.key
public_key =/etc/bdr/server/public.key
minimum_number_of_hops = 2 # avoid peers too local
local_sqlite = /etc/bdr/blob-peer-meta.sql
local_store = /home/bdr/blobs
notify_email = joe@foo.com
max_cores = 4 # maximum workers
contract_grace_period = 48 # hours.  The time that you agree to store blobs 
                           # even if the peer disappears.
keep_files_for= 28 # days
keep_local_copy_of_all_blobs = True # costs more disk, less reliant on peers


#2 file system walker - depends on #1, iterates over backup_dirs noting
      any new files, changed files, and deleted files.  Keeps state
      in sqlite (permission, size, timestamps, uid/gid).  Builds
      queue of new/changed files.  See walker.txt and schema.txt.
#2A find, download, compile, install, and build a usable test case
    for sqlite3 or similar lightweight SQL like queries

#3 Uploader depends on #1 - For each file in the queue it reads, compresses,
   and checksums it.  Ideally multiple core friendly.  As files are finished
   upload them to p2p server.  See uploader.txt.  Depends on #4 and #5 to
   actually upload.
#3A update https://github.com/wernerd/Skein3Fish to build with Go1.


#4 P2P server - speaks the p2p protocol for trading blobs, including those
                from the uploader.  Depends on #5 protocol and #1 init file.
                Continuously trades blobs, makes challenges, accepts challenges
                monitors and maintains redundancy.
#4A get test case with a few unique blobs each to successfully transfer
    blobs.

#5 implement code to implement p2p protocol (see protocol.txt) between
   SSL connected peers.  Connections should only be allowed to complete
   if the peer presents the public key in the sqlite database that
   tracks peers.
#5A write go code to connect with TLS/SSL and view the other ends public key
*DONE*
#5B get goprotobufs built/usable with working test code
#5B implement REQUEST, REPLY, and GET.  See protocol.txt
